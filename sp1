/*******************************
 * Kindle SRS ‚Äî Apps Script (Drive + Calendar, daily at 17:00)
 * BASE: your previous version + extensions:
 *  - Fill empty days (min words/day) by seeding new words (from CSV)
 *  - Plan next 60 days (from tomorrow) so there are no gaps
 *  - Definitions (cached), concept images (Wikipedia), IPA + dict audio
 *  - Optional Cloud TTS for sentence audio (off by default)
 *  - PDFs linked in Calendar at 17:00 (popup + email reminders)
 *******************************/

/** ---------- CONFIG (original kept) ---------- **/
const CSV_FILE_ID = '1vYdrc55cD4_II7itNAGB0LiDntMNBU8g'; // kindle_vocab.csv Drive file ID
const ROOT_PATH = 'KindleSRS';
const REVIEWS_SUBFOLDER = 'Reviews';
const STATE_FILENAME = 'srs_state.json';
const TIMEZONE = 'Europe/Zurich';
const REVIEW_HOUR = 17;
const REVIEW_MIN = 0;
const EVENT_DURATION_MIN = 15;
const SRS_OFFSETS = [1, 3, 7, 14, 30];
const CALENDAR_ID = 'primary';
const ADD_CAL_EMAIL_REMINDER = true;
const ADD_CAL_POPUP_REMINDER = true;
const SEND_EMAIL = false;
const SEND_TO_EMAIL = Session.getActiveUser().getEmail();
const MAX_WORDS_PER_DAY = 0; // 0 = no cap

/** ---------- NEW CONFIG (for ‚Äúno gaps‚Äù) ---------- **/
const MIN_WORDS_PER_DAY = 1;           // Guarantee at least N words per day
const PLAN_HORIZON_DAYS = 60;          // Plan next 60 days
const PREFILL_FROM_TOMORROW = true;    // true = tomorrow..+60; false = today..+60
const GENERATE_FUTURE_PDFS = true;     // Create PDFs for planned future days

// Definitions + images cache file
const DEF_CACHE_FILENAME = 'definitions_cache.json';

// Dictionary + Wikipedia endpoints
const DICT_ENDPOINT = (w) => `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(w)}`;
const WIKI_SUMMARY  = (w) => `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(w)}`;
const CONCEPT_IMG_MAX_WIDTH = 300; // px width in Doc

// === Audio / Pronunciation ===
const AUDIO_SUBFOLDER = 'Audio';
const DOWNLOAD_DICT_AUDIO = true; // save dictionary MP3s to Drive if present

// Optional Google Cloud Text-to-Speech (needs API/billing)
const CLOUD_TTS_ENABLED = false;
const CLOUD_TTS_API_KEY = 'YOUR_API_KEY';
const CLOUD_TTS_LANG = 'en-US';
const CLOUD_TTS_VOICE = 'en-US-Wavenet-F'; // female voice
const CLOUD_TTS_SPEAKING_RATE = 1.0;

/** ---------- ENTRYPOINTS ---------- **/
function runDaily() {
  _runForDate_(new Date());      // today
  _planHorizon_(new Date());     // ensure next 60 days have ‚â•1 word
}

function runOnce() {
  _runForDate_(new Date());
  _planHorizon_(new Date());
}

/** ---------- CORE LOGIC ---------- **/
function _runForDate_(jsDate) {
  const tz = TIMEZONE;
  const local = toLocalDate(jsDate, tz); // 00:00 local

  // Ensure folders & state
  const rootFolder    = ensureFolderPath_(ROOT_PATH);
  const reviewsFolder = ensureSubfolder_(rootFolder, REVIEWS_SUBFOLDER);
  const audioFolder   = ensureSubfolder_(rootFolder, AUDIO_SUBFOLDER);

  const stateFile = ensureStateFile_(rootFolder, STATE_FILENAME);
  const state     = readJson_(stateFile) || { meta: { version: 3 }, words: {}, daily: {} };

  // Definition cache (defs, imgs, ipa, dictAudio)
  const defCacheFile = ensureStateFile_(rootFolder, DEF_CACHE_FILENAME);
  const defCache     = readJson_(defCacheFile) || { defs: {}, imgs: {}, ipa: {}, dictAudio: {} };

  // Load CSV
  const csv  = DriveApp.getFileById(CSV_FILE_ID).getBlob().getDataAsString();
  const rows = Utilities.parseCsv(csv);
  if (!rows || rows.length < 2) throw new Error('CSV appears empty or malformed.');
  const header = rows[0].map(h => (h || '').trim());
  const req = ['Word', 'Stem', 'BookTitle', 'Context', 'DateAdded'];
  req.forEach(col => {
    if (header.indexOf(col) === -1) throw new Error('Missing column: ' + col + '. Found: ' + header.join(', '));
  });
  const idx = Object.fromEntries(header.map((h, i) => [h, i]));

  // Parse records
  const records = [];
  for (let r = 1; r < rows.length; r++) {
    const row  = rows[r];
    const word = safeStr_(row[idx.Word]);
    if (!word) continue;
    records.push({
      word: word,
      stem: safeStr_(row[idx.Stem]),
      context: safeStr_(row[idx.Context]),
      source: safeStr_(row[idx.BookTitle]),
      date: parseDate_(row[idx.DateAdded], tz) // Date | null
    });
  }

  // Merge into SRS state (unstarted pool; seed later as needed)
  let newWords = 0;
  records.forEach(rec => {
    const key = wordKey_(rec.word, rec.source);
    if (!state.words[key]) {
      state.words[key] = {
        word: rec.word,
        definition: rec.stem || '',
        context: rec.context || '',
        source: rec.source || '',
        first_seen: null,                 // unstarted
        due_days: SRS_OFFSETS.slice(),
        due_dates: [],
        original_date: rec.date ? toISODate_(rec.date, tz) : null,
        pron_ipa: '',
        image_url: '',
        audio_word_url: '',
        audio_sentence_url: ''
      };
      newWords++;
    } else {
      if (!state.words[key].definition && rec.stem) {
        state.words[key].definition = rec.stem;
      }
    }
  });

  // Ensure today's minimum words (seed if needed, borrow, or restart)
  _ensureMinForDay_(state, local, MIN_WORDS_PER_DAY);

  // Due list for today
  const todayISO = toISODate_(local, tz);
  let dueKeys = Object.keys(state.words).filter(k => {
    const w = state.words[k];
    return (w.due_dates || []).indexOf(todayISO) !== -1;
  });
  if (MAX_WORDS_PER_DAY > 0 && dueKeys.length > MAX_WORDS_PER_DAY) {
    dueKeys = dueKeys.slice(0, MAX_WORDS_PER_DAY);
  }

  // Hydrate: definitions, images, IPA + dict audio; optionally sentence TTS
  _hydrateDefinitions_(dueKeys, state, defCache);
  _hydrateConceptImages_(dueKeys, state, defCache);
  _downloadDictAudiosToDrive_(dueKeys, state, defCache, audioFolder);
  _ensureSentenceAudio_(dueKeys, state, audioFolder);

  // Create PDF & Calendar for today
  const daily = (state.daily[todayISO] = state.daily[todayISO] || {});
  daily.word_keys = dueKeys;

  const { pdfFileId, pdfLink } = generatePdfForDay_(local, dueKeys, state, reviewsFolder);
  daily.pdf_file_id = pdfFileId;
  daily.pdf_link    = pdfLink;

  const eventId = createOrUpdateEvent_(local, dueKeys.length, pdfLink);
  daily.event_id = eventId;

  // Optional email
  if (SEND_EMAIL) {
    try {
      MailApp.sendEmail({
        to: SEND_TO_EMAIL,
        subject: `Kindle SRS ‚Äî ${todayISO} (${dueKeys.length} words)`,
        htmlBody: `Your review PDF is ready: <a href="${pdfLink}">${pdfLink}</a>`
      });
    } catch (e) { console.log('MailApp send failed:', e); }
  }

  // Persist state + def cache
  writeJson_(stateFile, state);
  writeJson_(defCacheFile, defCache);

  console.log(`Done ${todayISO}: ${dueKeys.length} words ‚Ä¢ ${pdfLink} ‚Ä¢ new words merged: ${newWords}`);
}

/**
 * Plan ahead so no empty days for the next PLAN_HORIZON_DAYS.
 * Starts from tomorrow if PREFILL_FROM_TOMORROW = true.
 */
function _planHorizon_(startJsDate) {
  const tz = TIMEZONE;
  const rootFolder    = ensureFolderPath_(ROOT_PATH);
  const reviewsFolder = ensureSubfolder_(rootFolder, REVIEWS_SUBFOLDER);
  const audioFolder   = ensureSubfolder_(rootFolder, AUDIO_SUBFOLDER);

  const stateFile = ensureStateFile_(rootFolder, STATE_FILENAME);
  const state     = readJson_(stateFile) || { meta: { version: 3 }, words: {}, daily: {} };

  const defCacheFile = ensureStateFile_(rootFolder, DEF_CACHE_FILENAME);
  const defCache     = readJson_(defCacheFile) || { defs: {}, imgs: {}, ipa: {}, dictAudio: {} };

  let startLocal = toLocalDate(startJsDate, tz);
  if (PREFILL_FROM_TOMORROW) startLocal = addDays_(startLocal, 1);

  // Ensure each day has min words by seeding/borrowing/restart if needed
  for (let i = 0; i < PLAN_HORIZON_DAYS; i++) {
    const day = addDays_(startLocal, i);
    _ensureMinForDay_(state, day, MIN_WORDS_PER_DAY);
  }

  // Hydrate for the whole horizon
  const plannedKeys = _collectPlannedKeys_(state, startLocal, PLAN_HORIZON_DAYS - 1);
  _hydrateDefinitions_(plannedKeys, state, defCache);
  _hydrateConceptImages_(plannedKeys, state, defCache);
  _downloadDictAudiosToDrive_(plannedKeys, state, defCache, audioFolder);
  _ensureSentenceAudio_(plannedKeys, state, audioFolder);

  // Create events (+ PDFs if configured)
  for (let i = 0; i < PLAN_HORIZON_DAYS; i++) {
    const day = addDays_(startLocal, i);
    const ymd = toISODate_(day, tz);
    const keys = Object.keys(state.words).filter(k => (state.words[k].due_dates || []).indexOf(ymd) !== -1);
    if (!keys.length) continue;

    let pdfLink = '';
    if (GENERATE_FUTURE_PDFS) {
      const { pdfLink: link } = generatePdfForDay_((day), keys, state, reviewsFolder);
      pdfLink = link;
    } else {
      pdfLink = ensureFolderPath_(ROOT_PATH).getUrl();
    }

    createOrUpdateEvent_(day, keys.length, pdfLink);
    state.daily[ymd] = state.daily[ymd] || {};
    state.daily[ymd].word_keys = keys;
    state.daily[ymd].pdf_link  = pdfLink;
  }

  writeJson_(stateFile, state);
  writeJson_(defCacheFile, defCache);
}

/** ---------- PDF / DOC GENERATION ---------- **/
function generatePdfForDay_(localMidnight, wordKeys, state, reviewsFolder) {
  const todayISO = toISODate_(localMidnight, TIMEZONE);
  const title = `Kindle SRS ‚Äî ${todayISO} (${wordKeys.length} words)`;

  const doc = DocumentApp.create(title);
  const body = doc.getBody();
  body.appendParagraph(title).setHeading(DocumentApp.ParagraphHeading.TITLE);

  if (wordKeys.length === 0) {
    body.appendParagraph('No words due today. Keep reading! üìö');
  } else {
    let idx = 1;
    wordKeys.forEach(k => {
      const w = state.words[k];

      body.appendParagraph(`${idx}. ${w.word}${w.source ? ` ‚Äî ${w.source}` : ''}`)
          .setHeading(DocumentApp.ParagraphHeading.HEADING2);

      const ipa = (w.pron_ipa ? ` /${w.pron_ipa.replace(/^\/|\/$/g,'')}/` : '');
      body.appendParagraph(`Pronunciation:${ipa || ' [pending]'}`);

      body.appendParagraph(`Definition: ${w.definition ? w.definition : '[pending]'}`);
      if (w.context) body.appendParagraph(`Context: ${w.context}`);

      // Audio links
      if (w.audio_word_url) {
        const p = body.appendParagraph(`üîä Word audio: ${w.audio_word_url}`);
        try { p.setLinkUrl(w.audio_word_url); } catch (e) {}
      }
      if (w.audio_sentence_url) {
        const p2 = body.appendParagraph(`üó£Ô∏è Sentence audio: ${w.audio_sentence_url}`);
        try { p2.setLinkUrl(w.audio_sentence_url); } catch (e) {}
      }

      // Conceptual image under the definition
      if (w.image_url) {
        try {
          const imgRes = UrlFetchApp.fetch(w.image_url, { muteHttpExceptions: true });
          if (imgRes.getResponseCode() === 200) {
            const blob = imgRes.getBlob();
            const img = body.appendImage(blob);
            try { img.setWidth(CONCEPT_IMG_MAX_WIDTH); } catch (e) {}
          }
        } catch (e) { /* ignore */ }
      }

      body.appendParagraph(''); // spacer
      idx++;
    });
  }

  doc.saveAndClose();

  // Move Doc under ROOT_PATH (tidy), export to PDF
  const docFile = DriveApp.getFileById(doc.getId());
  const rootFolder = ensureFolderPath_(ROOT_PATH);
  try { rootFolder.addFile(docFile); } catch (e) {}
  try { DriveApp.getRootFolder().removeFile(docFile); } catch (e) {}

  const pdfBlob = docFile.getAs(MimeType.PDF).setName(`srs_${todayISO}.pdf`);
  const existing = findFileInFolderByName_(reviewsFolder, pdfBlob.getName());
  let pdfFile;
  if (existing) {
    existing.setTrashed(true);
    pdfFile = reviewsFolder.createFile(pdfBlob);
  } else {
    pdfFile = reviewsFolder.createFile(pdfBlob);
  }
  pdfFile.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

  return { pdfFileId: pdfFile.getId(), pdfLink: pdfFile.getUrl() };
}

/** ---------- CALENDAR ---------- **/
function createOrUpdateEvent_(localMidnight, nWords, pdfLink) {
  const cal = (CALENDAR_ID === 'primary')
    ? CalendarApp.getDefaultCalendar()
    : CalendarApp.getCalendarById(CALENDAR_ID);

  const start = new Date(localMidnight);
  start.setHours(REVIEW_HOUR, REVIEW_MIN, 0, 0);
  const end = new Date(start.getTime() + EVENT_DURATION_MIN * 60000);

  const dateStr = toISODate_(localMidnight, TIMEZONE);
  const summary = `Kindle SRS Review ‚Äî ${dateStr} (${nWords} words)`;
  const description = `Daily spaced repetition review.\nPDF: ${pdfLink}\nSRS_DATE=${dateStr}`;

  const events = cal.getEvents(start, end, { search: 'Kindle SRS Review ‚Äî ' + dateStr });
  let ev = events && events.length ? events[0] : null;

  if (ev) {
    ev.setTitle(summary).setDescription(description).setTime(start, end);
    try { ev.removeAllReminders(); } catch (e) {}
  } else {
    ev = cal.createEvent(summary, start, end, { description });
  }

  if (ADD_CAL_POPUP_REMINDER) { try { ev.addPopupReminder(0); } catch (e) {} }
  if (ADD_CAL_EMAIL_REMINDER) { try { ev.addEmailReminder(0); } catch (e) {} }

  return ev.getId();
}

/** ---------- NO-GAPS HELPERS (seed, borrow, restart) ---------- **/
// Ensure a given day has at least N words. Priority:
// 1) Seed unstarted words (true SRS from today)
// 2) Borrow from soonest upcoming dues (extra review today, keep future due)
// 3) Restart cycle for completed words (latest due < today): add today + 1,3,7,14,30
function _ensureMinForDay_(state, localMidnight, minCount) {
  const tz = TIMEZONE;
  const ymd = toISODate_(localMidnight, tz);

  const countForDay = () =>
    Object.keys(state.words).filter(k => (state.words[k].due_dates || []).indexOf(ymd) !== -1).length;

  const need = () => Math.max(0, minCount - countForDay());
  if (need() <= 0) return;

  // --- Tier 1: seed unstarted ---
  {
    const pool = Object.keys(state.words).filter(k => !state.words[k].first_seen);
    let seeded = 0;
    while (need() > 0 && pool.length) {
      const k = pool.shift();
      _seedWordFromDate_(state, k, localMidnight);
      seeded++;
    }
    if (need() <= 0) return;
  }

  // --- Tier 2: borrow from upcoming dues (within next 7 days) ---
  {
    const horizonDays = 7;
    const candidates = [];
    for (let i = 1; i <= horizonDays; i++) {
      const futureYMD = toISODate_(addDays_(localMidnight, i), tz);
      Object.keys(state.words).forEach(key => {
        const s = state.words[key];
        const due = s.due_dates || [];
        if (due.indexOf(futureYMD) !== -1 && due.indexOf(ymd) === -1) {
          candidates.push({ key, dist: i });
        }
      });
    }
    candidates.sort((a, b) => a.dist - b.dist || (a.key < b.key ? -1 : 1));

    const picked = new Set();
    for (let i = 0; i < candidates.length && need() > 0; i++) {
      const { key } = candidates[i];
      if (picked.has(key)) continue;
      picked.add(key);
      const s = state.words[key];
      const set = new Set(s.due_dates || []);
      set.add(ymd); // extra review today
      s.due_dates = Array.from(set).sort();
    }
    if (need() <= 0) return;
  }

  // --- Tier 3: restart cycle for completed words ---
  {
    const completed = Object.keys(state.words).filter(key => {
      const due = (state.words[key].due_dates || []).slice().sort();
      if (!due.length) return false;
      const last = due[due.length - 1];
      return last < ymd; // all dues in the past
    });
    completed.sort();

    for (let i = 0; i < completed.length && need() > 0; i++) {
      const key = completed[i];
      const s = state.words[key];
      const set = new Set(s.due_dates || []);
      set.add(ymd);
      SRS_OFFSETS.forEach(off => {
        const d = addDays_(localMidnight, off);
        set.add(toISODate_(d, tz));
      });
      s.due_dates = Array.from(set).sort();
      // optional tracking: s.restarted_count = (s.restarted_count || 0) + 1;
    }
  }
}

// Set first_seen = given date; schedule 0 + 1,3,7,14,30 into due_dates
function _seedWordFromDate_(state, key, localMidnight) {
  const tz = TIMEZONE;
  const ymd0 = toISODate_(localMidnight, tz);
  const w = state.words[key];
  if (!w) return;
  if (!w.due_days || !w.due_days.length) w.due_days = SRS_OFFSETS.slice();

  w.first_seen = ymd0;

  const dates = [ymd0];
  SRS_OFFSETS.forEach(off => {
    const d = addDays_(localMidnight, off);
    dates.push(toISODate_(d, tz));
  });

  const set = new Set([...(w.due_dates || []), ...dates]);
  w.due_dates = Array.from(set).sort();
}

// Gather all word keys scheduled within horizon
function _collectPlannedKeys_(state, startLocal, horizonDays) {
  const tz = TIMEZONE;
  const out = new Set();
  for (let i = 0; i <= horizonDays; i++) {
    const d = addDays_(startLocal, i);
    const y = toISODate_(d, tz);
    Object.keys(state.words).forEach(k => {
      if ((state.words[k].due_dates || []).indexOf(y) !== -1) out.add(k);
    });
  }
  return Array.from(out);
}

/** ---------- HYDRATION: defs, images, audio ---------- **/
function _hydrateDefinitions_(keys, state, defCache) {
  defCache.defs = defCache.defs || {};
  defCache.ipa  = defCache.ipa  || {};
  defCache.dictAudio = defCache.dictAudio || {};

  keys.forEach(k => {
    const w = state.words[k];
    if (!w) return;

    const lc = (w.word || '').toLowerCase();

    let needDef = !(w.definition && w.definition.trim());
    let needIPA = !(w.pron_ipa && w.pron_ipa.trim());
    let needDictAudio = !(w.audio_word_url && w.audio_word_url.trim());

    if (needDef && defCache.defs[lc]) { w.definition = defCache.defs[lc]; needDef = false; }
    if (needIPA && defCache.ipa[lc])   { w.pron_ipa   = defCache.ipa[lc];  needIPA = false; }
    if (needDictAudio && defCache.dictAudio[lc]) {
      w.audio_word_url = defCache.dictAudio[lc];
      needDictAudio = false;
    }

    if (!needDef && !needIPA && !needDictAudio) return;

    try {
      const resp = UrlFetchApp.fetch(DICT_ENDPOINT(w.word), { muteHttpExceptions: true });
      if (resp.getResponseCode() !== 200) return;
      const data = JSON.parse(resp.getContentText());
      if (Array.isArray(data) && data.length) {
        if (needDef && data[0].meanings?.length) {
          const defs = data[0].meanings[0].definitions || [];
          if (defs.length && defs[0].definition) {
            w.definition = String(defs[0].definition).trim();
            defCache.defs[lc] = w.definition;
            needDef = false;
          }
        }
        const ph = data[0].phonetics || [];
        if (ph.length) {
          if (needIPA) {
            const ipa = (ph.find(p => p.text)?.text) || '';
            if (ipa) { w.pron_ipa = ipa; defCache.ipa[lc] = ipa; needIPA = false; }
          }
          if (needDictAudio) {
            const audioUrl = (ph.find(p => p.audio)?.audio) || '';
            if (audioUrl) {
              w.audio_word_url = audioUrl; // may be replaced by Drive link later
              defCache.dictAudio[lc] = w.audio_word_url;
              needDictAudio = false;
            }
          }
        }
      }
    } catch (e) { /* ignore */ }
  });
}

// Concept images: cache Wikipedia thumbnail URLs
function _hydrateConceptImages_(keys, state, defCache) {
  defCache.imgs = defCache.imgs || {};
  keys.forEach(k => {
    const w = state.words[k];
    if (!w) return;
    const wc = (w.word || '').toLowerCase();
    if (w.image_url && w.image_url.trim()) return;
    if (defCache.imgs[wc] && defCache.imgs[wc].trim()) { w.image_url = defCache.imgs[wc]; return; }

    const url = _fetchWikiThumbUrl_(w.word);
    if (url) {
      w.image_url = url;
      defCache.imgs[wc] = url;
    } else {
      defCache.imgs[wc] = '';
    }
  });
}

function _fetchWikiThumbUrl_(word) {
  try {
    const res = UrlFetchApp.fetch(WIKI_SUMMARY(word), { muteHttpExceptions: true });
    if (res.getResponseCode() !== 200) return '';
    const data = JSON.parse(res.getContentText());
    if (data && data.thumbnail && data.thumbnail.source) {
      return String(data.thumbnail.source);
    }
  } catch (e) { /* ignore */ }
  return '';
}

// Download dictionary audio MP3s to Drive (optional), replace URL with Drive link
function _downloadDictAudiosToDrive_(keys, state, defCache, audioFolder) {
  if (!DOWNLOAD_DICT_AUDIO) return;

  keys.forEach(k => {
    const w = state.words[k];
    if (!w || !w.audio_word_url) return;

    // Already Drive link?
    if (w.audio_word_url.startsWith('https://drive.google.com/')) return;

    try {
      const res = UrlFetchApp.fetch(w.audio_word_url, { muteHttpExceptions: true });
      if (res.getResponseCode() !== 200) return;
      const blob = res.getBlob().setName(`${(w.word||'word')}.mp3`);
      const f = audioFolder.createFile(blob);
      f.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
      w.audio_word_url = f.getUrl(); // overwrite with Drive link
      const lc = (w.word || '').toLowerCase();
      defCache.dictAudio[lc] = w.audio_word_url;
    } catch (e) { /* ignore */ }
  });
}

// Optional: synthesize sentence audio via Google Cloud TTS (needs API enabled)
function _ensureSentenceAudio_(keys, state, audioFolder) {
  if (!CLOUD_TTS_ENABLED) return;

  keys.forEach(k => {
    const w = state.words[k];
    if (!w) return;
    if (w.audio_sentence_url && w.audio_sentence_url.trim()) return;

    const sentence = (w.context && w.context.trim())
      ? w.context.trim()
      : `Here is an example using the word ${w.word} in a sentence.`;

    const url = _ttsSynthesize_(sentence, `${(w.word||'word')}_sentence`, audioFolder);
    if (url) w.audio_sentence_url = url;
  });
}

function _ttsSynthesize_(text, filenameBase, audioFolder) {
  if (!CLOUD_TTS_ENABLED || !CLOUD_TTS_API_KEY) return '';

  const url = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${encodeURIComponent(CLOUD_TTS_API_KEY)}`;
  const payload = {
    input: { text: text },
    voice: { languageCode: CLOUD_TTS_LANG, name: CLOUD_TTS_VOICE },
    audioConfig: { audioEncoding: 'MP3', speakingRate: CLOUD_TTS_SPEAKING_RATE }
  };

  try {
    const resp = UrlFetchApp.fetch(url, {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });
    if (resp.getResponseCode() !== 200) return '';
    const data = JSON.parse(resp.getContentText());
    if (!data.audioContent) return '';
    const blob = Utilities.newBlob(Utilities.base64Decode(data.audioContent), 'audio/mpeg', `${filenameBase}.mp3`);
    const file = audioFolder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    return file.getUrl();
  } catch (e) {
    return '';
  }
}

/** ---------- UTIL / STATE ---------- **/
function ensureFolderPath_(pathStr) {
  const parts = pathStr.split('/').map(s => s.trim()).filter(Boolean);
  let folder = DriveApp.getRootFolder();
  parts.forEach(name => {
    const it = folder.getFoldersByName(name);
    folder = it.hasNext() ? it.next() : folder.createFolder(name);
  });
  return folder;
}

function ensureSubfolder_(parent, name) {
  const it = parent.getFoldersByName(name);
  return it.hasNext() ? it.next() : parent.createFolder(name);
}

function ensureStateFile_(parentFolder, name) {
  const it = parentFolder.getFilesByName(name);
  return it.hasNext() ? it.next() : parentFolder.createFile(name, JSON.stringify({}), MimeType.PLAIN_TEXT);
}

function readJson_(file) {
  try { return JSON.parse(file.getBlob().getDataAsString()); }
  catch (e) { return null; }
}

function writeJson_(file, obj) {
  file.setTrashed(true);
  const parent = file.getParents().hasNext() ? file.getParents().next() : DriveApp.getRootFolder();
  const fresh = parent.createFile(file.getName(), JSON.stringify(obj, null, 2), MimeType.PLAIN_TEXT);
  return fresh;
}

function findFileInFolderByName_(folder, name) {
  const it = folder.getFilesByName(name);
  return it.hasNext() ? it.next() : null;
}

function toLocalDate(date, tz) {
  const str = Utilities.formatDate(date, tz, 'yyyy-MM-dd');
  return new Date(str + 'T00:00:00' + offsetISO_(tz));
}

function toISODate_(date, tz) {
  return Utilities.formatDate(date, tz, 'yyyy-MM-dd');
}

function addDays_(date, days) {
  const d = new Date(date.getTime());
  d.setDate(d.getDate() + days);
  return d;
}

function safeStr_(v) {
  return (v == null) ? '' : String(v).trim();
}

function wordKey_(word, source) {
  return Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_1, (word.toLowerCase() + '|' + (source||'').toLowerCase()))
    .map(b => (b + 256).toString(16).slice(-2)).join('');
}

function parseDate_(val, tz) {
  if (!val) return null;
  const d = new Date(val);
  if (!isNaN(d.getTime())) {
    const isoDay = Utilities.formatDate(d, tz, 'yyyy-MM-dd');
    return new Date(isoDay + 'T00:00:00' + offsetISO_(tz));
  }
  return null;
}

// crude but sufficient offset string for midnight
function offsetISO_(tz) {
  const now = new Date();
  const m = Utilities.formatDate(now, tz, 'Z').match(/([+-]\d{2})(\d{2})/);
  const hh = Number(m[1]);
  const mm = Number(m[2]);
  const total = (Math.sign(hh) >= 0 ? 1 : -1) * (Math.abs(hh) * 60 + mm);
  const sign = total >= 0 ? '+' : '-';
  const abs = Math.abs(total);
  const H = String(Math.floor(abs / 60)).padStart(2, '0');
  const M = String(abs % 60).padStart(2, '0');
  return `${sign}${H}:${M}`;
}

/** ---------- Backfill helpers (kept) ---------- **/
function backfillDays(N) {
  if (typeof N !== 'number' || N < 1) N = 60;
  const start = new Date();
  for (let i = 0; i < N; i++) {
    const day = new Date(start);
    day.setDate(start.getDate() + i);
    _runForDate_(day);
  }
}

function backfillRange(startISO, endISO) {
  const start = new Date(startISO + 'T00:00:00');
  const end   = new Date(endISO   + 'T00:00:00');
  for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
    _runForDate_(new Date(d));
  }
}

function backfillFromTomorrow(N) {
  if (typeof N !== 'number' || N < 1) N = 60;
  const t = new Date();
  const start = new Date(t);
  start.setDate(t.getDate() + 1);
  for (let i = 0; i < N; i++) {
    const day = new Date(start);
    day.setDate(start.getDate() + i);
    _runForDate_(day);
  }
}
